\documentclass[conference]{IEEEtran}
% \IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
% Template version as of 6/27/2024

\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\graphicspath{
    {img/}
}
\begin{document}

\title{An Implementation of Product Construction on Deterministic Finite Automata in Python}

\author{
\IEEEauthorblockN{Evan Childers}
\IEEEauthorblockA{
\textit{University of Alabama}\\
Tuscaloosa, Alabama, United States \\
epchilders@crimson.ua.edu}
\and
\IEEEauthorblockN{August Connors}
\IEEEauthorblockA{
\textit{University of Alabama}\\
Tuscaloosa, Alabama, United States \\
ahconnors@crimson.ua.edu}
\and
\IEEEauthorblockN{Kai NeSmith}
\IEEEauthorblockA{
\textit{University of Alabama}\\
Tuscaloosa, Alabama, United States \\
klnesmith@crimson.ua.edu}
}

\maketitle

\begin{abstract}
ABSTRACT HERE - ALL
\end{abstract}

\section{Introduction}
\textbf{INTRODUCTION HERE - EVAN (ALL)}
In automata theory, product construction describes the method of which two deterministic finite automata (DFA's) are combined into a single DFA to accept a language that is derived from a certain boolean operation on the languages of the original DFA's such as intersection and union. This method plays a pivotal role in many applications in computing theory and formal language processing. In particular, product construction provides a means for which relationships between regular languages can be explored. By constructing a product DFA, one can effectively evaluate whether two DFA's accept overlapping inputs, meet certain logical requirements or satisfying a desired system behavior.
\section{Problem Statement}
\textbf{PROBLEM STATEMENT HERE - EVAN}
While the process of DFA product construction is a well understood concept in automata theory, the manual computation of a product DFA can become extremely complex and error-prone as the size of the DFA's involved increase. Additionally, the intricacy of these product DFA's can often complicate the process of verifying logical operations like the intersection and union of different automata. This sparks the need for a programmatic solution capable of systematically identifying the product states and transitions, simulating the traversal of a DFA given an input string and presenting the resulting automaton in a clear and interpretable form. This work addresses the lack of available resources regarding this issue by detailing the implementation and formal proof for product construction in Python, along with it's potential use cases in verifying logical expressions.
\section{Implementation}
\textbf{IMPLEMENTATION DETAILS HERE - AUGIE}

\section{Experiments}
In this section, we will explore how product construction can be applied to a variety of different DFA's with a focus on the differences between intersection and union as well as identifying the causes of unreachable states in the resulting automaton
\subsection{Experiment 1}
In this experiment, we will be computing the product construction of the following DFA's using the intersection operations:

\begin{table}[h!]
\centering
\caption{DFA 1 Transition Table}
\begin{tabular}{|c|c|c|}
\hline
 & 0 & 1 \\
\hline
$\rightarrow$a\textsubscript{0} & a\textsubscript{1} & a\textsubscript{1} \\
\hline
a\textsubscript{1} & a\textsubscript{r} & a\textsubscript{2} \\
\hline
a\textsubscript{2}(accept) & a\textsubscript{2} & a\textsubscript{2} \\
\hline
a\textsubscript{r} & a\textsubscript{r} & a\textsubscript{r} \\
\hline
\end{tabular}
\label{table:dfa1}
\end{table}
\begin{table}[h!]
\centering
\caption{DFA 2 Transition Table}
\begin{tabular}{|c|c|c|}
\hline
 & 0 & 1 \\
\hline
$\rightarrow$b\textsubscript{0} & b\textsubscript{1} & b\textsubscript{0} \\
\hline
b\textsubscript{1}(accept) & b\textsubscript{1} & b\textsubscript{1} \\
\hline
\end{tabular}
\label{table:dfa1}
\end{table}
When computing the product of these two DFA's, the resulting transition table is:
\begin{table}[h]
\caption{Product DFA Transition Table}
\centering
\begin{tabular}{|c|c|c|}
\hline
 & 0 & 1 \\
\hline
$\rightarrow$a\textsubscript{0},b\textsubscript{0} & a\textsubscript{1},b\textsubscript{1} & a\textsubscript{1},b\textsubscript{0} \\
\hline
a\textsubscript{0},b\textsubscript{1} & a\textsubscript{1},b\textsubscript{1} & a\textsubscript{1},b\textsubscript{1} \\
\hline
a\textsubscript{1},b\textsubscript{0} & a\textsubscript{r},b\textsubscript{1} & a\textsubscript{2},b\textsubscript{0} \\
\hline
a\textsubscript{1},b\textsubscript{1} & a\textsubscript{r},b\textsubscript{1} & a\textsubscript{2},b\textsubscript{1} \\
\hline
a\textsubscript{2},b\textsubscript{0} & a\textsubscript{2},b\textsubscript{1} & a\textsubscript{2},b\textsubscript{0} \\
\hline
a\textsubscript{2},b\textsubscript{1}(accept) & a\textsubscript{2},b\textsubscript{1} & a\textsubscript{2},b\textsubscript{1} \\
\hline
a\textsubscript{r},b\textsubscript{0} & a\textsubscript{r},b\textsubscript{1} & a\textsubscript{r},b\textsubscript{0} \\
\hline
a\textsubscript{r},b\textsubscript{1} & a\textsubscript{r},b\textsubscript{1} & a\textsubscript{r},b\textsubscript{1} \\
\hline
\end{tabular}
\label{table:dfa1}
\end{table} \\
With the algorithmically determined unreachable states being $a_0,b_1$ and $a_r,b_0$.\\ (DETAIL WHY THESE ARE UNREACHABLE HERE)

In order to verify the intersection and union properties, we use the \texttt{accepts\_string} method to test string acceptance in the product DFA. The results demonstrate the logical operations between the original DFAs:

\begin{table}[h!]
\centering
\caption{Boolean Analysis of Product DFA Operations}
\label{table:dfa_boolean}
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{DFA Type} & \textbf{11} & \textbf{00} & \textbf{01} & \textbf{1} \\ \hline
DFA 1 & True & False & True & False \\ \hline
DFA 2 & False & True & True & False \\ \hline
Union DFA & True & True & True & False \\ \hline
Intersection DFA & False & False & True & False \\ \hline
\end{tabular}
\end{table} 

As shown in table, the union DFA accepts a string if either original DFA accepts it ($\text{DFA}_1 \cup \text{DFA}_2$), while the intersection DFA only accepts strings accepted by both ($\text{DFA}_1 \cap \text{DFA}_2$). The results confirm the correct implementation of these Boolean operations.


\subsection{Experiment 2}


\textbf{EXPERIMENTS HERE - EVAN \& KAI}

\section{Contributions}
\subsection{Evan Childers}
\textbf{EVAN CONTRIBUTIONS HERE}
\subsection{August Connors}
\textbf{AUGIE CONTRIBUTIONS HERE}
\subsection{Kai NeSmith}
\textbf{KAI CONTRIBUTIONS HERE}

\section{Conclusion}
\textbf{CONCLUSION HER - KAI (ALL)}

% Not sure if we'll need a bibliography, so leaving the template here in case.
\begin{thebibliography}{00}
\bibitem{b1} G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,'' Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.
\end{thebibliography}

\end{document}
